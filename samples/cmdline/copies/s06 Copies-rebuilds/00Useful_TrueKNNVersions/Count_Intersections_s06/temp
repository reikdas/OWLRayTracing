//
	//				ROUND 2
	//
	//Re-launch for sparse points with final radius from prev round
	owlParamsSet1i(lp,"callNum",3);
	numRounds = 0;
	foundKNN = 0;
	std::cout<<"\nSparse points\n";
	while(!foundKNN) //&& (stop==0 | stop==1))
	{
		std::cout<<"\n===============================================================================================================\n";
		std::cout<<"Round: "<<++numRounds<<" Radius = "<<radius<<'\n';

		//Start timer for ray casting	
		round_start = std::chrono::steady_clock::now();
		owlLaunch2D(rayGen,fbSize.x,fbSize.y,lp);
		fb = (const Neigh*)owlBufferGetPointer(frameBuffer,0);

		foundKNN = 1;
		
		//Counting number of points left after each round
		count=0;
		for(int j=0; j<Spheres.size(); j++)
		{
			//num_intersections += fb[j*knn].intersections;
			if(fb[j*knn].numNeighbors >= knn/2)
				count++;
			
		}
		std::cout<<"Points with no neighbors = "<<count<<'\n';
		
		//Determine if we need another round
		for(int j=0; j<Spheres.size(); j++)
		{
			if(fb[j*knn].numNeighbors > 0)
			{
				foundKNN = 0;
				radius *= 4;
				owlGeomSet1f(SpheresGeom,"rad",radius);
				owlParamsSet1f(lp,"distRadius",radius);
				owlGroupRefitAccel(spheresGroup);
				owlGroupRefitAccel(world); 

				break;
				
			}	
		}
	}



//RayGen
     if(optixLaunchParams.callNum == 3)
  {
	if(optixLaunchParams.frameBuffer[xID*knn].numNeighbors == -1)
  		optixLaunchParams.frameBuffer[xID*knn].numNeighbors = knn;
	if(optixLaunchParams.frameBuffer[xID*knn].numNeighbors > 0)	
	{
		owl::Ray ray(optixLaunchParams.spheres[xID].center, vec3f(0,0,1), 0, 1.e-16f);
 	 	owl::traceRay(self.world, ray, color);
 	}

  }

  if(optixLaunchParams.callNum == 2)
  {
	//printf("sparse\n");
	if(optixLaunchParams.frameBuffer[xID*knn].numNeighbors >= knn/2)
		optixLaunchParams.frameBuffer[xID*knn].numNeighbors = -1;
  }
